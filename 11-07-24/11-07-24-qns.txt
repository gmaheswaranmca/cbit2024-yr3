Q **Binary Tree Maximum Path Sum** - [LeetCode 124]
https://leetcode.com/problems/binary-tree-maximum-path-sum/
Steps
    Define the Recursive Function:
        This function should take a node as input and 
        return the maximum path sum that starts from the node and 
        extends to either its left or right child.
    Base Case:
        If the node is None, return 0 because an empty subtree 
        contributes nothing to the path sum.
    Recursive Case:
        Recursively calculate the maximum path sum for the left and right subtrees.
        Compute the maximum path sum that passes through the current node and 
        includes the left and right children.
        Update the global maximum path sum if the current path sum is greater than 
        the previously recorded maximum.
    Return Value:
        Return the maximum path sum that includes the current node and 
        extends to one of its subtrees.

Q **Construct Binary Tree from Preorder and Inorder Traversal** - [LeetCode 105]
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
### Approach to Solve

1. **Understanding the Relationship**:
   - In preorder traversal, 
        the first element is always the root of the subtree.
   - In inorder traversal, 
        elements to the left of the root belong to the left subtree, 
        and elements to the right belong to the right subtree.

2. **Recursive Construction**:
   - Use a recursive approach where:
     - The current subtree's root is the first element of the preorder array.
     - Find this root in the inorder array to determine the left and right subtrees.
     - Recursively construct the left and right subtrees.

3. **Steps**:
   - Start with the preorder and inorder arrays.
   - Extract the root from the preorder array.
   - Find the index of this root in the inorder array to split it into left and right subtrees.
   - Recursively construct the left and right subtrees using the respective parts of the preorder and inorder arrays.

Q **Lowest Common Ancestor of a Binary Tree** - [LeetCode 236]
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

### Approach to Solve
1. **Recursive DFS Approach**:
   - Perform a Depth-First Search (DFS) starting from the root of the tree.
   - If the current node is `None` or matches either `p` or `q`, return the current node.
   - Recursively search the left and right subtrees.
   - If both `p` and `q` are found in separate subtrees (`left` and `right`), then the current node is the LCA.
   - If only one of `p` or `q` is found, return that node as a potential LCA for its subtree.
   - If neither `p` nor `q` is found in either subtree, return `None`.

2. **Base Case**:
   - If the current node is `None`, return `None`.
   - If the current node matches `p` or `q`, return the current node.

3. **Recursive Case**:
   - Recursively search the left subtree and store the result in `left`.
   - Recursively search the right subtree and store the result in `right`.

4. **Return Value**:
   - If both `left` and `right` are not `None`, it means `p` and `q` are found in different subtrees, so return the current node.
   - If only one of `left` or `right` is `None`, return the non-`None` value (potential LCA found in one subtree).
   - If both `left` and `right` are `None`, return `None`.


Q
**Kth Smallest Element in a BST** - [LeetCode 230]
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

Approach:
    inorder ie recursion 

Q
**Range Sum of BST** - [LeetCode 938]
https://leetcode.com/problems/range-sum-of-bst/

**Recursive DFS Approach**:
   - Perform a Depth-First Search (DFS) starting from the root of the tree.
   - Use the BST property to decide whether to explore left or right subtrees or to add the current node's value to the sum.
   - Traverse each node and add its value to the sum if it lies within the range `[L, R]`.