
1. Inorder Traversal
**Problem:** [Binary Tree Inorder Traversal]
(https://leetcode.com/problems/binary-tree-inorder-traversal/)
(https://www.hackerrank.com/challenges/tree-inorder-traversal/problem)

2. Preorder Traversal
**Problem:** [Binary Tree Preorder Traversal]
(https://leetcode.com/problems/binary-tree-preorder-traversal/)
(https://www.hackerrank.com/challenges/tree-preorder-traversal/problem)

def preOrder(root):
    #Write your code here
    if (root is None):
        return
    print(root.info, end=' ')
    preOrder(root.left)
    preOrder(root.right)

3. Postorder Traversal
**Problem:** [Binary Tree Postorder Traversal]
(https://leetcode.com/problems/binary-tree-postorder-traversal/)
(https://www.hackerrank.com/challenges/tree-postorder-traversal/problem)
def postOrder(root):
    #Write your code here
    if not root:
        return
    postOrder(root.left)
    postOrder(root.right)
    print(root.info, end=' ')

4. Level Order Traversal
**Problem:** [Binary Tree Level Order Traversal]
(https://leetcode.com/problems/binary-tree-level-order-traversal/)
(https://www.codechef.com/problems/BINTREE)

from collections import deque
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        queue = deque([[root]])
        res = []
        while queue:
            nodes = queue.popleft()
            
            nodes_val = []
            for node in nodes:
                nodes_val.append(node.val)
                children = []
                if node.left:
                    children.append(node.left)
                if node.right:
                    children.append(node.right)
                queue.append(children)
            if(len(nodes_val) > 0):    
                res.append(nodes_val)

        return res
            

Find depth value which the sub list index where we append the queue popped value.
    def findDepth(root):
        #base cond 
        if not root: 
            return 0
        #logic for max depth 
        ldepth = findDepth(root.left)
        rdepth = findDepth(root.right)

        depth = max(ldepth,rdepth) + 1

        return depth

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        res = [] 
        root_depth = findDepth(root)
        for I in range(root_depth): #[[],[],[]] -> res 
            res.append([])

        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            #visit code 
            node_depth = findDepth(node)
            print({'val':node.val,'depth':node_depth}, end=' ')
            res[node_depth-1].append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        # res = [[nodes of level 2],[nodes of level 1],[nodes of level 0]]
        return res[::-1]

The depth is not applicable to find the position of the node in the level index.
code is with bug. To solve, 
    we have to use the findHeight() 
        which will give us the level index 
            at which we may add the node val.

----- Satya fixed the bug. ----- 
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        queue = deque([root])
        res = []
        while queue:
            level_size = len(queue)
            level_nodes = []
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level_nodes)
        return res

